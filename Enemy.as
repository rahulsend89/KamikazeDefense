package {	import flash.display.MovieClip;	import flash.text.TextField;	import flash.display.*;	import flash.events.*;	import flash.utils.Timer;	import flash.geom.ColorTransform;	import bar_mc;	import GameClass;	import flash.geom.Rectangle;	import Comman;	class Enemy extends Comman {		/*		_in_area is the value which get true when Enemy get in the visible Area and then Fire		 */		public var _in_area:Boolean;		public var speed:Number;		var numDoors:Number;		var color:String;		public var bar:bar_mc;		public var press:Boolean;		public var per:Number;		public var reduceVal:Number;		public var _reduceVal:Number;		public var _type:Number;		private var _b:Number;		public var shootVal:Number;		private var shoot:Boolean;		public var removed:Boolean;		private var shipArray:Array;		private var timer:Timer;		private var startShooting_val:Boolean;		public function Enemy() {			shoot = false;			startShooting_val = true;			speed = 1;			_b = 0;			_in_area = false;			removed = false;			_reduceVal = 0.1;			reduceVal = 1;			_type = 0;			shootVal = 0.5;			per = 100;			bar = new bar_mc();			bar.name = "bar_mc";			var holder_mc:MovieClip = this.getChildByName("holder_mc") as MovieClip;			bar.x = holder_mc.x;			bar.y = holder_mc.y;			this.addChild(bar);			this.mouseChildren = false;			this.press  = false;			timer = new Timer(100,4);			timer.addEventListener( TimerEvent.TIMER, doit_timer);			this.addEventListener(Event.ADDED_TO_STAGE,parent_);		}		override public function parent_(e:Event):void {									mainClass = (this.root as MovieClip);			var mc:MovieClip = mainClass.main_mc.holder_mc.getChildByName("ship_mc");			shipArray = new Array(mc);			super.parent_(e);		}		public function doit_timer(e:TimerEvent):void {			if (shoot) {				shoot = false;			} else {				shoot = true;			}		}		override public function loopUntilRemoved(e:Event):void{			if (!mainClass.main_mc.gamePause) {				var bar_mc:MovieClip = e.currentTarget.getChildByName("bar_mc") as MovieClip;				bar_mc.gotoAndStop(Math.floor ((bar_mc.totalFrames * per) / 100));				point((e.currentTarget as MovieClip),shipArray[0] as MovieClip);				if (e.currentTarget.shoot) {					e.currentTarget._b++;					//if (e.currentTarget._b%3==0) {					shootFire((e.currentTarget as MovieClip),shipArray,mainClass.main_mc.bulletholder_mc,e.currentTarget._b,1);					//}				}				if (per<=1 && !removed) {					per = 1;					mainClass.main_mc.power_mc.calculate_Power();					removed = true;					mainClass.main_mc.doit(this);				}				if (this._in_area && startShooting_val) {					startShooting_val = false;					timer.start();				}			}		}		public function shootFire(clip_mc:MovieClip, clipar:Array, attach:MovieClip, j:Number, dspeed:Number) {			var stack_:stack_e = new stack_e();			var mc:MovieClip = attach.addChild (stack_) as MovieClip;			var newColorTransform:ColorTransform = mc.transform.colorTransform;			newColorTransform.color = 0xff0000;			//mc.transform.colorTransform = newColorTransform;			mc.name = "stack" + j + "_mc";			mc.x = clip_mc.x;			mc.y = clip_mc.y;			mc.rotation = clip_mc.point_mc.rotation - 90;			mc.scale = 100;			mc.temp = 15;			mc.hit = true;			mc.speed = 10;			mc.shootVal = 1;			mc.isUser = false;			mc.clipar = clipar;		}			override public function point(clip1:MovieClip, clip2:MovieClip) {			if (clip2 == root) {				clip1.point_mc.rotation = (Math.atan2 (clip1.y - root.mouseY, clip1.x - root.mouseX) * 180 / Math.PI)-90;				return clip1.rotation;			} else {				clip1.rot = clip1.point_mc.rotation = (Math.atan2 (clip1.y - clip2.y, clip1.x - clip2.x) * 180 / Math.PI)-90;				return clip1.rotation;			}		}	}}