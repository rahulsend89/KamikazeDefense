package {	import flash.display.MovieClip;	import flash.text.TextField;	import flash.display.*;	import flash.events.*;	import flash.utils.Timer;	import bar_mc;	import GameClass;	import flash.utils.getDefinitionByName;	import flash.display.BitmapData;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Rectangle;	class Bose1 extends MovieClip {		public var _in_area:Boolean;		public var speed:Number;		var numDoors:Number;		var color:String;		public var bar:bar_mc;		public var press:Boolean;		public var per:Number;		public var reduceVal:Number;		public var _reduceVal:Number;		public var _type:Number;		private var _b:Number;		public var shootVal:Number;		public var shoot:Boolean;		public var removed:Boolean;		private var shipArray:Array;		private var timer:Timer;		private var ymov:Number;		private var startShooting_val:Boolean;		public function Bose1() {			ymov = 30;			shoot = false;			startShooting_val = true;			speed = 1;			_b = 0;			_in_area = false;			removed = false;			_reduceVal = 0.1;			reduceVal = 1;			_type = 0;			shootVal = 0.5;			per = 100;			bar = new bar_mc();			bar.name = "bar_mc";			var holder_mc:MovieClip = this.getChildByName("holder_mc") as MovieClip;			bar.x = holder_mc.x;			bar.y = holder_mc.y;			this.addChild(bar);			this.mouseChildren = false;			this.press  = false;			this.addEventListener(Event.REMOVED_FROM_STAGE,removeS);			timer = new Timer(100,4);			timer.addEventListener( TimerEvent.TIMER, doit_timer);			this.addEventListener(Event.ADDED_TO_STAGE,parent_);		}		private function parent_(e:Event):void {			var mainClass = (this.root as MovieClip);			//trace("mainClass : "+mainClass)			this.addEventListener(Event.ENTER_FRAME,doit);			var mc:MovieClip = mainClass.main_mc.holder_mc.getChildByName("ship_mc");			//trace(mc+" : mainClass.main_mc.holder_mc.ship_mc");			shipArray = new Array(mc);		}		public function doit_timer(e:TimerEvent):void {			shoot = true;		}		public function removeS(event:Event):void {			this.removeEventListener(Event.REMOVED_FROM_STAGE , removeS);			this.removeEventListener(Event.ENTER_FRAME , doit);		}		public function doit(e:Event):void {			var mainClass = (this.root as MovieClip);			if (!mainClass.main_mc.gamePause) {				e.target.y += (Math.sin(ymov/20)*4);				ymov+=1;				//trace(mainClass.main_mc.bulletholder_mc+" : mainClass :"+shipArray+" : ");				if (mainClass!=null) {					var bar_mc:MovieClip = e.target.getChildByName("bar_mc") as MovieClip;					bar_mc.gotoAndStop(Math.floor ((bar_mc.totalFrames * per) / 100));					point((e.target as MovieClip),shipArray[0] as MovieClip);					if (e.target.shoot) {						e.target._b++;						if (e.target._b%7==0) {						shootFire((e.target as MovieClip),shipArray,mainClass.main_mc.bulletholder_mc,e.target._b,1);						}					}					if (per<=1 && !removed) {						per = 1;						removed = true;						this.removeEventListener(Event.ENTER_FRAME , doit);						mainClass.main_mc.doit(this);					}					if (this._in_area && startShooting_val) {						startShooting_val = false;						timer.start();					}				}			}		}		public function shootFire(clip_mc:MovieClip, clipar:Array, attach:MovieClip, j:Number, dspeed:Number) {			var mainClass = (this.root as MovieClip);			for (var count:Number=1; count<=1; count++) {				var stack_:stack_e = new stack_e();				var mc:MovieClip = attach.addChild (stack_) as MovieClip;				mc.name = "stack" + j +""+count+ "_mc";				var point_mc:MovieClip = clip_mc.getChildByName("point"+count+"_mc") as MovieClip;				mc.rotation = point_mc.rotation - 90;				//trace(point_mc.name+" : point_mc");				mc.x = point_mc.x+clip_mc.x;				mc.y = point_mc.y+clip_mc.y;				mc.scale = 100;				mc.temp = 15;				mc.hit = true;				point_mc.rotation = point(clip_mc,clipar[0]);				//trace(clip_mc+" : clip_mc :"+clipar[0]+" : ");				mc.addEventListener(Event.ENTER_FRAME , doit_);				mc.addEventListener(Event.REMOVED_FROM_STAGE,removeEvent_doit_);				//trace(this.clipAr+" : ClipAr");				function removeEvent_doit_(e:Event):void {					//trace("Removed : "+e.target);					e.target.removeEventListener(Event.ENTER_FRAME,doit_);				}				function doit_(e:Event):void {					if (stage!=null && !mainClass.main_mc.gamePause) {						if (this!=null) {							var angle:Number = (e.target.rotation + 90) * Math.PI / 180;							var xmov:Number = Math.sin (angle) * 10;							var ymov:Number = Math.cos (angle) * 10;						}						if (e.target.scale > 200) {							e.target.temp *= -1;						}						if (e.target.scale <= 0) {							//e.target.hit = false;							//e.target.gotoAndPlay (2);						}						//trace((e.target!=null)+" : "+(stage!=null));						if (e.target.x > stage.stageWidth || e.target.y > stage.stageHeight-60 || e.target.x < 0 || e.target.y < 0) {							//e.target.hit = false;							//e.target.gotoAndPlay (2);							var mc:MovieClip = (e.target.parent as MovieClip);							if (mc!=null) {								//trace("removed : "+e.target.name)								mc.removeChild(e.target as MovieClip);							}						}						for (var count:Number = 0; count < clipar.length; count++) {							var clip_mc:MovieClip = clipar[count];							var rect:Rectangle = new Rectangle(0,0,0,0);							rect = getCollisionRect ((e.target as DisplayObject), clip_mc,mainClass.main_mc,true,255);							//trace(clip_mc+" : ");							if ((rect.width!=0 ||rect.height!=0) && e.target.hit) {								xmov = 0;								ymov = 0;								//clip_mc.recudeVal = reduceVal;								clip_mc.per -= shootVal;								e.target.hit = false;								e.target.gotoAndPlay(2);							}						}						if (e.target.hit) {							e.target.x += xmov;							e.target.y -= ymov;						}					} else {						var mc_:MovieClip = (e.target.parent as MovieClip);						if (mc_!=null) {							e.target.removeEventListener(Event.ENTER_FRAME , doit_);							mc_.removeChild(e.target as MovieClip);						}					}				}			}		}		public function getCollisionRect(target1:DisplayObject,target2:DisplayObject,commonParent:DisplayObjectContainer,pixelPrecise:Boolean=false,tolerance:int=255):Rectangle {			var rect1:Rectangle=target1.getBounds(commonParent);			var rect2:Rectangle=target2.getBounds(commonParent);			var intersectionRect:Rectangle=rect1.intersection(rect2);			if (! pixelPrecise) {				return intersectionRect;			}			intersectionRect.x=Math.floor(intersectionRect.x);			intersectionRect.y=Math.floor(intersectionRect.y);			intersectionRect.width=Math.ceil(intersectionRect.width);			intersectionRect.height=Math.ceil(intersectionRect.height);			if (intersectionRect.isEmpty()) {				return intersectionRect;			}			var parentXformInvert:Matrix=commonParent.transform.concatenatedMatrix.clone();			parentXformInvert.invert();			var target1Xform:Matrix=target1.transform.concatenatedMatrix.clone();			target1Xform.concat(parentXformInvert);			var target2Xform:Matrix=target2.transform.concatenatedMatrix.clone();			target2Xform.concat(parentXformInvert);			target1Xform.translate(- intersectionRect.x,- intersectionRect.y);			target2Xform.translate(- intersectionRect.x,- intersectionRect.y);			var bd:BitmapData=new BitmapData(intersectionRect.width,intersectionRect.height,false);			bd.draw(target1,target1Xform,new ColorTransform(1,1,1,1,255,-255,-255,tolerance),BlendMode.NORMAL);			bd.draw(target2,target2Xform,new ColorTransform(1,1,1,1,255,255,255,tolerance),BlendMode.DIFFERENCE);			var overlapRect:Rectangle=bd.getColorBoundsRect(0xffffffff,0xff00ffff);			overlapRect.offset(intersectionRect.x,intersectionRect.y);			return overlapRect;		}		public function point(clip1:MovieClip, clip2:MovieClip) {			if (clip2 == root) {				clip1.point_mc.rotation = (Math.atan2 (clip1.y - root.mouseY, clip1.x - root.mouseX) * 180 / Math.PI)-90;				return clip1.rotation;			} else {				clip1.rot= (Math.atan2 (clip1.y - clip2.y, clip1.x - clip2.x) * 180 / Math.PI)-90;				return clip1.rot;			}		}		/*public function Click (event:MouseEvent):void {		var mainClass = (this.root as MovieClip);		var mc:MovieClip = mainClass.main_mc.gun_mc.cur_mc;		if (this.hitTestObject(mc)) {		//trace (+" : mc");		trace ("Working : "+mc);		this.press = true;		}		}		public function mouseout (event:MouseEvent):void {		this.press = false;		}*/	}}